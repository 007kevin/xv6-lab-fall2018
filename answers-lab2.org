1. Assuming that the following JOS kernel code is correct, what type
   should variable x have, uintptr_t or physaddr_t?
   #+BEGIN_SRC c
     mystery_t x;
     char* value = return_a_pointer();
     *value = 10;
     x = (mystery_t) value;   
   #+END_SRC
   *Answer*
   x should be of type uintptr_t virtual address type since
   executing code pointers are virtual addresses that are always
   translated by the MMU

2. What entries (rows) in the page directory have been filled in at
   this point? What addresses do they map and where do they point? In
   other words, fill out this table as much as possible:

| Entry | Base Virtual Address | Points to (logically):                             |
|  1023 | *0xffx00000*         | Page table for top 4MB of phys memory              |
|  1022 | *0xff800000*         | *page table for holding RAM*                       |
| *960* | *0xf0000000*         | *page table holding mappings for beginning of RAM* |
| *959* | *0xefc00000*         | *writable kernal stack*                            |
| *956* | *0xef000000*         | *page table containing page structs (readonly)*    |
|     2 | 0x00800000           | *unmapped*                                         |
|     1 | 0x00400000           | *unmapped*                                         |
|     0 | 0x00000000           | *unmapped* [see next question]                     |

3. We have placed the kernel and user environment in the same address
   space. Why will user programs not be able to read or write the
   kernel's memory? What specific mechanisms protect the kernel
   memory?

   user programs will not be able to read/write kernel memory due to
   the permission bits set on the kernel page table.

4. What is the maximum amount of physical memory that this operating
   system can support? Why?

   Xv6 maps the first 256 MB of RAM to the last 256MB of the virtual
   address space so this is the max supported.

5. How much space overhead is there for managing memory, if we
   actually had the maximum amount of physical memory? How is this
   overhead broken down?




6. Revisit the page table setup in kern/entry.S and
n   kern/entrypgdir.c. Immediately after we turn on paging, EIP is
   still a low number (a little over 1MB). At what point do we
   transition to running at an EIP above KERNBASE? What makes it
   possible for us to continue executing at a low EIP between when we
   enable paging and when we begin running at an EIP above KERNBASE?
   Why is this transition necessary?



